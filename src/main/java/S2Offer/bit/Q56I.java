package S2Offer.bit;

/**
 * @Author: HB
 * @Description: 面试题56I - 数组中数字出现的次数
 *               描述: 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。
 *               请写程序找出这两个只出现一次的数字。
 *               要求时间复杂度是O(n)，空间复杂度是O(1)。
 *               Case:
 *                   Input: nums = [4,1,4,6]
 *                   Output: [1,6] 或 [6,1]
 *               Limit: 2 <= nums.length <= 10000
 *               Remark:
 * @CreateDate: 10:51 2021/2/18
 */

public class Q56I {

    /**
     * @Author: HB
     * @Description: 位运算解法
     * @Date: 10:53 2021/2/18
     * @Params: null
     * @Returns:
    */
    // 异或运算: 任何一个数字异或自身都等于0. 那么当数组中除了一个数字之外，其他数字都出现了两次, 可以依次异或数组中的每一个元素, 剩下的结果即为出现一次的元素.
    // 对于除两个数字之外，其他数字都出现了两次的情况, 能否将数组分为两部分, 第一个子数组包含了一个出现一次的数组, 另一个子数组包含了另一个出现一次的数组, 在对两个子数组分别进行异或, 以便求出结果.
    // 算法思路:
    // 1. 对输入数组依次进行异或, 异或结果为两个只出现一次的元素的异或值, 设为x;
    // 2. 异或值x的二进制形式中定有一位为1, 找到最后一个为1的位的位置, 记为第n位;
    // 3. 根据第n位的二进制是否位1为标准将数组分为两个子数组, 将两个只出现一次的元素分别分配到了两个子数组之中;
    // 4. 可以先计算出一个值, 然后利用自反性计算另一个值.
    public int[] singleNumbers(int[] nums) {

        // 1. 对输入数组依次进行异或, 异或结果为两个只出现一次的元素的异或值, 设为x;
        int XOR = nums[0];
        for (int i = 1; i < nums.length; i++) {
            XOR ^= nums[i];
        }

        // 2. 异或值x的二进制形式中定有一位为1, 找到最后一个为1的位的位置, 记为第n位;
        // 例如XOR(2) = 00001000, n(2) = 1000
        int n = getLowBits(XOR);

        // 3. 根据第n位的二进制是否位1为标准将数组分为两个子数组, 将两个只出现一次的元素分别分配到了两个子数组之中;
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            if ((nums[i] & n) == 0) {
                res ^= nums[i];
            }
        }

        // 4. 可以先计算出一个值, 然后利用自反性计算另一个值.
        return new int[] {res, XOR ^ res};

    }

    public int getLowBits (int x) {
        return x & (-x);
    }

}
